"use strict";(self.webpackChunkwebsitev_3=self.webpackChunkwebsitev_3||[]).push([[21],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return m}});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(n),m=o,b=d["".concat(l,".").concat(m)]||d[m]||u[m]||a;return n?r.createElement(b,i(i({ref:t},p),{},{components:n})):r.createElement(b,i({ref:t},p))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var c=2;c<a;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},1325:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return l},default:function(){return m},frontMatter:function(){return s},metadata:function(){return c},toc:function(){return u}});var r=n(7462),o=n(3366),a=(n(7294),n(3905)),i=["components"],s={id:"jobs",title:"Jobs",sidebar_label:"Jobs",sidebar_position:5},l=void 0,c={unversionedId:"basics/jobs",id:"version-2.x/basics/jobs",title:"Jobs",description:"Jobs are pre-programmed background processes that can be scheduled to run after a certain period of time.",source:"@site/versioned_docs/version-2.x/basics/jobs.md",sourceDirName:"basics",slug:"/basics/jobs",permalink:"/docs/2.x/basics/jobs",editUrl:"https://github.com/facebook/docusaurus/edit/main/website/docs/basics/jobs.md",tags:[],version:"2.x",sidebarPosition:5,frontMatter:{id:"jobs",title:"Jobs",sidebar_label:"Jobs",sidebar_position:5},sidebar:"version-2.x/tutorialSidebar",previous:{title:"Collections",permalink:"/docs/2.x/basics/collections"},next:{title:"Authentication",permalink:"/docs/2.x/modules/authentication"}},p={},u=[{value:"Structure of the main jobs of the application",id:"structure-of-the-main-jobs-of-the-application",level:2},{value:"Types of jobs",id:"types-of-jobs",level:2},{value:"Event jobs",id:"event-jobs",level:3},{value:"Recurrent jobs",id:"recurrent-jobs",level:3},{value:"Example",id:"example",level:2}],d={toc:u};function m(e){var t=e.components,n=(0,o.Z)(e,i);return(0,a.kt)("wrapper",(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"Jobs")," are pre-programmed background processes that can be scheduled to run after a certain period of time."),(0,a.kt)("h2",{id:"structure-of-the-main-jobs-of-the-application"},"Structure of the main jobs of the application"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"server\n\u2514\u2500\u2500 app\n    \u2514\u2500\u2500 jobs\n        \u251c\u2500\u2500 job1\n        \u2502   \u2514\u2500\u2500 index.js\n        \u251c\u2500\u2500 job2\n        \u2514\u2500\u2500 index.js\n")),(0,a.kt)("h2",{id:"types-of-jobs"},"Types of jobs"),(0,a.kt)("p",null,"There are two types of jobs. All jobs have cluster support (run only once on any server) and the execution of the jobs may not be in the same server from which it was called."),(0,a.kt)("h3",{id:"event-jobs"},"Event jobs"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const myJob = job({\n  type: 'event',\n  async run(params) {\n    // execute something\n  }\n})\n\nmyJob(params, {\n  waitToRun: 1000 // run after 1000 ms\n})\n")),(0,a.kt)("p",null,"To call a event job you must call the job function returned from the initialization."),(0,a.kt)("h3",{id:"recurrent-jobs"},"Recurrent jobs"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"export default job({\n  type: 'recurrent',\n  runEvery: 1000 // runs every 1000 ms\n  async getNextRun () { // return the date of the next execution\n    return moment().add(1, 'day').toDate()\n  },\n  async run(params) {\n    // execute something\n  }\n})\n")),(0,a.kt)("p",null,"This jobs will be called automatically. You can only specify ",(0,a.kt)("inlineCode",{parentName:"p"},"runEvery")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"getNextRun")," in a job."),(0,a.kt)("h2",{id:"example"},"Example"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"import {start} from '@orion-js/jobs'\nimport job1 from './job1'\nimport job2 from './job2'\n\nstart({job1, job2})\n")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"start")," makes the jobs declared inside valid and ready to be called."),(0,a.kt)("p",null,"Jobs can be called at any moment and make changes in the database. Let's take for example the next resolver:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"import {resolver} from '@orion-js/app'\nimport Orders from 'app/collections/Orders'\nimport checkDeliveryFromOrder from 'app/jobs/checkDeliveryFromOrder'\n\nexport default resolver({\n  params: {\n    orderId: {\n      type: 'ID'\n    }\n  },\n  returns: true,\n  mutation: true,\n  async resolve({orderId}, viewer) {\n    const order = await Orders.findOne(orderId)\n    const delivery = await order.delivery()\n    if (delivery.status !== 'completed') {\n      const oneDay = 1000 * 60 * 60 * 24\n      checkDeliveryFromOrder({orderId}, {waitToRun: oneDay})\n    }\n    return true\n  }\n})\n")),(0,a.kt)("p",null,"The resolver checks if a delivery asociated to an order has been completed. Since is still in its way, it calls the job ",(0,a.kt)("inlineCode",{parentName:"p"},"checkDeliveryFromOrder")," with a time period equal to a day. This means that it will be executed 24 hours from now."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"import {job} from '@orion-js/jobs'\nimport Orders from 'app/collections/Orders'\n\nexport default job({\n  type: 'event',\n  async run({orderId}) {\n    const order = await Orders.findOne(orderId)\n    const delivery = await order.delivery()\n    if (delivery.status === 'completed') {\n      await order.update({$set: {status: 'delivered'}})\n    } else {\n      const threeDays = 1000 * 60 * 60 * 24 * 3\n      this.runJob({orderId}, {waitToRun: threeDays})\n    }\n  }\n})\n")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"checkDeliveryFromOrder")," receives the ",(0,a.kt)("inlineCode",{parentName:"p"},"orderId")," parameter, and it checks again if the delivery has been completed. If by now the delivery has been completed, it updates ",(0,a.kt)("inlineCode",{parentName:"p"},"order.status = 'delivered'"),". At contrary, it runs the job again, now with a time expectancy of 3 days."))}m.isMDXComponent=!0}}]);